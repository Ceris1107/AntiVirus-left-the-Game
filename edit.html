<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=0.3, maximum-scale=1.0, user-scalable=no">
    <title>Статичная Three.js Сцена 3:2</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            overflow: hidden;
            background: #000;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #000;
        }
        
        #container {
            position: relative;
            width: 100%;
            height: 100%;
            max-width: 1200px;  /* Максимальная ширина */
            max-height: 800px;  /* Максимальная высота для соотношения 3:2 (1200x800) */
            aspect-ratio: 3/2;  /* Фиксированное соотношение 3:2 */
            margin: auto;
        }
        
        #scene-container {
            width: 100%;
            height: 100%;
            position: relative;
        }
        
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        
        .controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            display: flex;
            gap: 10px;
        }
        
        .control-btn {
            padding: 10px 20px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 5px;
            cursor: pointer;
            font-family: sans-serif;
            font-size: 14px;
            transition: all 0.3s ease;
            backdrop-filter: blur(5px);
        }
        
        .control-btn:hover {
            background: rgba(30, 30, 30, 0.9);
            border-color: rgba(255, 255, 255, 0.6);
        }
        
        .fullscreen-indicator {
            position: absolute;
            top: 10px;
            right: 10px;
            color: white;
            font-family: sans-serif;
            font-size: 12px;
            background: rgba(0, 0, 0, 0.5);
            padding: 5px 10px;
            border-radius: 3px;
            z-index: 100;
            display: none;
        }
        
        /* Стили для полноэкранного режима */
        :fullscreen #container {
            max-width: 100vw;
            max-height: 100vh;
            width: 100vw;
            height: 100vh;
        }
        
        :fullscreen .fullscreen-indicator {
            display: block;
        }
        
        /* Для поддержки разных браузеров */
        :-webkit-full-screen #container {
            max-width: 100vw;
            max-height: 100vh;
            width: 100vw;
            height: 100vh;
        }
        
        :-moz-full-screen #container {
            max-width: 100vw;
            max-height: 100vh;
            width: 100vw;
            height: 100vh;
        }
        
        :-ms-fullscreen #container {
            max-width: 100vw;
            max-height: 100vh;
            width: 100vw;
            height: 100vh;
        }
    </style>
</head>
<body>
    <div id="container">
        <div class="fullscreen-indicator">Полный экран</div>
        <div id="scene-container"></div>
        <div class="controls">
            <button id="fullscreen-btn" class="control-btn">Полный экран</button>
            <button id="exit-fullscreen-btn" class="control-btn" style="display: none;">Выйти</button>
        </div>
    </div>

    <!-- Three.js и необходимые библиотеки -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.min.js"></script>
    
    <!-- Основной скрипт -->
    <script>
        // ============================
        // КОНФИГУРАЦИЯ СЦЕНЫ
        // ============================
        
        // Фиксированное соотношение сторон
        const ASPECT_RATIO = 3/2; // 3:2
        
        // Конфигурация камеры
        const cameraConfig = {
            position: { x: 0.35,y: 1.5, z: 6 },
            rotation: { x: -0.3, y: -0.05, z: 0},
            fov: 30,
            near: 0.1,
            far: 1000
        };
        
        // Конфигурация сцены
        const sceneConfig = {
            backgroundColor: 0x111111,
            centerModel: true,
            modelScale: 1.0
        };
        
        // Конфигурация рендерера
        const rendererConfig = {
            antialias: true,
            alpha: false,
            shadowMapEnabled: true,
            shadowMapType: THREE.PCFSoftShadowMap
        };
        
        // ============================
        // КОНФИГУРАЦИЯ ОСВЕЩЕНИЯ
        // ============================
        
        const lightsConfig = [
            {
                type: 'AmbientLight',
                color: 0x404040,
                intensity: 1,
                enabled: true
            },
            {
                type: 'DirectionalLight',
                color: 0xffff00,
                intensity: 5,
                position: { x: -2.0, y: 0.2, z: -0.4},
                targetPosition: { x: -1.8 , y: 0, z: -0.4 },
                castShadow: true,
                shadowSettings: {
                    mapSize: 4096,
                    camera: { 
                        near: 0.1, 
                        far: 10, 
                        left: -5, 
                        right: 5, 
                        top: 5, 
                        bottom: -5
                    },
                    bias: 0.0001,
                    normalBias: 0.01,
                    radius: 0.01
                },
                enabled: false
            },
            {
                type: 'DirectionalLight',
                color: 0xffff00,
                intensity: 3,
                position: { x: -10.0, y: 0.2, z: -0.4},
                targetPosition: { x: -9.8, y: 0, z: -0.4 },
                castShadow: true,
                enabled: true
            },
            {
                type: 'PointLight', // MAIN LIGHT
                color: 0x9999ff,
                intensity: 6,
                position: { x: 0.4, y: 1, z: 2.5},
                distance: 30,
                decay: 0.1,
                castShadow: true,
                shadowSettings: {
                    mapSize: 1024,
                    camera: { near: 0, far: 50 },
                    bias: 0.001,
                    normalBias: 0.2,
                    radius: 5
                },
                enabled: true
            }
        ];
        
        // ============================
        // ПЕРЕМЕННЫЕ
        // ============================
        
        let scene, camera, renderer;
        let container, sceneContainer;
        let modelLoaded = false;
        let isFullscreen = false;
        
        // ============================
        // ИНИЦИАЛИЗАЦИЯ
        // ============================
        
        function init() {
            // Получаем контейнеры
            container = document.getElementById('container');
            sceneContainer = document.getElementById('scene-container');
            
            // Создание сцены
            scene = new THREE.Scene();
            scene.background = new THREE.Color(sceneConfig.backgroundColor);
            
            // Создание камеры с фиксированным соотношением сторон
            createCamera();
            
            // Создание рендерера
            renderer = new THREE.WebGLRenderer({
                antialias: rendererConfig.antialias,
                alpha: rendererConfig.alpha
            });
            
            // Настройка теней
            renderer.shadowMap.enabled = rendererConfig.shadowMapEnabled;
            renderer.shadowMap.type = rendererConfig.shadowMapType;
            renderer.shadowMap.autoUpdate = false;
            renderer.shadowMap.needsUpdate = true;
            renderer.physicallyCorrectLights = true;
            
            // Добавление рендерера в DOM
            sceneContainer.appendChild(renderer.domElement);
            
            // Добавление источников света
            createLights();
            
            // Загрузка модели
            loadModel();
            
            // Настройка кнопок полноэкранного режима
            setupFullscreenControls();
            
            // Инициализация размера
            updateSize();
            
            // Обработка изменения размера окна
            window.addEventListener('resize', updateSize, false);
            
            // Рендеринг сцены
            renderStaticScene();
        }
        
        function createCamera() {
            camera = new THREE.PerspectiveCamera(
                cameraConfig.fov,
                ASPECT_RATIO,  // Фиксированное соотношение сторон
                cameraConfig.near,
                cameraConfig.far
            );
            
            camera.position.set(
                cameraConfig.position.x,
                cameraConfig.position.y,
                cameraConfig.position.z
            );
            
            camera.rotation.set(
                cameraConfig.rotation.x,
                cameraConfig.rotation.y,
                cameraConfig.rotation.z
            );
            
            camera.updateMatrixWorld();
            camera.updateProjectionMatrix();
        }
        
        function createLights() {
            lightsConfig.forEach(config => {
                if (!config.enabled) return;
                
                let light;
                
                switch(config.type) {
                    case 'AmbientLight':
                        light = new THREE.AmbientLight(config.color, config.intensity);
                        break;
                        
                    case 'DirectionalLight':
                        light = new THREE.DirectionalLight(config.color, config.intensity);
                        light.position.set(config.position.x, config.position.y, config.position.z);
                        
                        const target = new THREE.Object3D();
                        target.position.set(config.targetPosition.x, config.targetPosition.y, config.targetPosition.z);
                        scene.add(target);
                        light.target = target;
                        
                        if (config.castShadow && config.shadowSettings) {
                            light.castShadow = true;
                            
                            const mapSize = config.shadowSettings.mapSize || 1024;
                            light.shadow.mapSize.width = mapSize;
                            light.shadow.mapSize.height = mapSize;
                            
                            if (config.shadowSettings.camera) {
                                const cam = config.shadowSettings.camera;
                                light.shadow.camera.near = cam.near || 0.5;
                                light.shadow.camera.far = cam.far || 500;
                                light.shadow.camera.left = cam.left || -50;
                                light.shadow.camera.right = cam.right || 50;
                                light.shadow.camera.top = cam.top || 50;
                                light.shadow.camera.bottom = cam.bottom || -50;
                                light.shadow.camera.updateProjectionMatrix();
                            }
                            
                            if (config.shadowSettings.bias !== undefined) {
                                light.shadow.bias = config.shadowSettings.bias;
                            }
                            if (config.shadowSettings.normalBias !== undefined) {
                                light.shadow.normalBias = config.shadowSettings.normalBias;
                            }
                            if (config.shadowSettings.radius !== undefined) {
                                light.shadow.radius = config.shadowSettings.radius;
                            }
                        }
                        break;
                        
                    case 'PointLight':
                        light = new THREE.PointLight(
                            config.color,
                            config.intensity,
                            config.distance,
                            config.decay
                        );
                        light.position.set(config.position.x, config.position.y, config.position.z);
                        
                        if (config.castShadow && config.shadowSettings) {
                            light.castShadow = true;
                            
                            const mapSize = config.shadowSettings.mapSize || 512;
                            light.shadow.mapSize.width = mapSize;
                            light.shadow.mapSize.height = mapSize;
                            
                            if (config.shadowSettings.camera) {
                                light.shadow.camera.near = config.shadowSettings.camera.near || 0.1;
                                light.shadow.camera.far = config.shadowSettings.camera.far || 30;
                                light.shadow.camera.updateProjectionMatrix();
                            }
                            
                            if (config.shadowSettings.bias !== undefined) {
                                light.shadow.bias = config.shadowSettings.bias;
                            }
                            if (config.shadowSettings.normalBias !== undefined) {
                                light.shadow.normalBias = config.shadowSettings.normalBias;
                            }
                            if (config.shadowSettings.radius !== undefined) {
                                light.shadow.radius = config.shadowSettings.radius;
                            }
                        }
                        break;
                }
                
                if (light) {
                    scene.add(light);
                }
            });
        }
        
        function loadModel() {
            const loader = new THREE.GLTFLoader();
            
            loader.load(
                'menu.glb',
                function(gltf) {
                    const model = gltf.scene;
                    
                    // Включение теней для всех объектов модели
                    model.traverse(function(node) {
                        if (node.isMesh) {
                            node.castShadow = true;
                            node.receiveShadow = true;
                            
                            if (node.material) {
                                node.material.shadowSide = THREE.FrontSide;
                                node.material.side = THREE.DoubleSide;
                            }
                        }
                    });
                    
                    // Центрирование модели
                    if (sceneConfig.centerModel) {
                        const box = new THREE.Box3().setFromObject(model);
                        const center = box.getCenter(new THREE.Vector3());
                        const size = box.getSize(new THREE.Vector3());
                        
                        model.position.sub(center);
                        
                        // Масштабируем модель
                        const maxSize = Math.max(size.x, size.y, size.z);
                        const targetSize = 10;
                        
                        if (maxSize > 0) {
                            const scale = targetSize / maxSize;
                            model.scale.multiplyScalar(scale * sceneConfig.modelScale);
                        }
                    } else {
                        model.scale.set(sceneConfig.modelScale, sceneConfig.modelScale, sceneConfig.modelScale);
                    }
                    
                    scene.add(model);
                    modelLoaded = true;
                    
                    // Обновляем тени
                    renderer.shadowMap.needsUpdate = true;
                    
                    // Рендеринг сцены
                    renderStaticScene();
                },
                function(xhr) {
                    console.log(`Загружено: ${Math.round(xhr.loaded / xhr.total * 100)}%`);
                },
                function(error) {
                    console.error('Ошибка загрузки модели:', error);
                    renderStaticScene();
                }
            );
        }
        
        function updateSize() {
            // Получаем размеры контейнера
            const containerWidth = container.clientWidth;
            const containerHeight = container.clientHeight;
            
            // Обновляем размер рендерера
            renderer.setSize(containerWidth, containerHeight);
            
            // Обновляем соотношение сторон камеры
            camera.aspect = containerWidth / containerHeight;
            
            // Корректируем FOV для сохранения одинакового вида
            // Это важно для фиксированного соотношения 3:2
            const targetAspect = ASPECT_RATIO;
            const currentAspect = containerWidth / containerHeight;
            
            if (currentAspect > targetAspect) {
                // Шире, чем 3:2 - увеличиваем FOV по горизонтали
                camera.fov = 2 * Math.atan(Math.tan(cameraConfig.fov * Math.PI / 360) * (currentAspect / targetAspect)) * 180 / Math.PI;
            } else {
                // Уже, чем 3:2 - используем базовый FOV
                camera.fov = cameraConfig.fov;
            }
            
            camera.updateProjectionMatrix();
            renderStaticScene();
        }
        
        function renderStaticScene() {
            camera.updateMatrixWorld();
            camera.updateProjectionMatrix();
            renderer.render(scene, camera);
        }
        
        // ============================
        // ПОЛНОЭКРАННЫЙ РЕЖИМ
        // ============================
        
        function setupFullscreenControls() {
            const fullscreenBtn = document.getElementById('fullscreen-btn');
            const exitFullscreenBtn = document.getElementById('exit-fullscreen-btn');
            
            // Функция для входа в полноэкранный режим
            async function enterFullscreen() {
                try {
                    if (container.requestFullscreen) {
                        await container.requestFullscreen();
                    } else if (container.webkitRequestFullscreen) {
                        await container.webkitRequestFullscreen();
                    } else if (container.mozRequestFullScreen) {
                        await container.mozRequestFullScreen();
                    } else if (container.msRequestFullscreen) {
                        await container.msRequestFullscreen();
                    }
                    isFullscreen = true;
                    updateFullscreenButtons();
                    updateSize(); // Обновляем размеры после входа в полноэкранный режим
                } catch (err) {
                    console.error('Ошибка при входе в полноэкранный режим:', err);
                }
            }
            
            // Функция для выхода из полноэкранного режима
            async function exitFullscreen() {
                try {
                    if (document.exitFullscreen) {
                        await document.exitFullscreen();
                    } else if (document.webkitExitFullscreen) {
                        await document.webkitExitFullscreen();
                    } else if (document.mozCancelFullScreen) {
                        await document.mozCancelFullScreen();
                    } else if (document.msExitFullscreen) {
                        await document.msExitFullscreen();
                    }
                    isFullscreen = false;
                    updateFullscreenButtons();
                    updateSize(); // Обновляем размеры после выхода
                } catch (err) {
                    console.error('Ошибка при выходе из полноэкранного режима:', err);
                }
            }
            
            // Обновление видимости кнопок
            function updateFullscreenButtons() {
                if (isFullscreen) {
                    fullscreenBtn.style.display = 'none';
                    exitFullscreenBtn.style.display = 'block';
                } else {
                    fullscreenBtn.style.display = 'block';
                    exitFullscreenBtn.style.display = 'none';
                }
            }
            
            // Обработчики событий
            fullscreenBtn.addEventListener('click', enterFullscreen);
            exitFullscreenBtn.addEventListener('click', exitFullscreen);
            
            // Слушатель события изменения полноэкранного режима
            document.addEventListener('fullscreenchange', handleFullscreenChange);
            document.addEventListener('webkitfullscreenchange', handleFullscreenChange);
            document.addEventListener('mozfullscreenchange', handleFullscreenChange);
            document.addEventListener('MSFullscreenChange', handleFullscreenChange);
            
            function handleFullscreenChange() {
                isFullscreen = !!(
                    document.fullscreenElement ||
                    document.webkitFullscreenElement ||
                    document.mozFullScreenElement ||
                    document.msFullscreenElement
                );
                updateFullscreenButtons();
                updateSize(); // Обновляем размеры при изменении режима
            }
            
            // Горячая клавиша для выхода из полноэкранного режима (Escape)
            document.addEventListener('keydown', function(event) {
                if (event.key === 'Escape' && isFullscreen) {
                    exitFullscreen();
                }
            });
        }
        
        // ============================
        // ЗАПУСК ПРИЛОЖЕНИЯ
        // ============================
        
        // Запуск приложения
        init();
        
        // Экспериментальная опция: повторный рендеринг через 2 секунды
        setTimeout(() => {
            renderer.shadowMap.needsUpdate = true;
            renderStaticScene();
        }, 2000);
    </script>
</body>
</html>